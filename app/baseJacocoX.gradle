buildscript {
    ext.jacoco_version = "0.8.4"
    ext.JacocoX_version = '1.0.5'
    //源代码路径，有多少个module，就在这里写多少个路径，如果你只有app一个module，那么就写一个就可以
    ext.coverageSourceDirs = []
    ext.jacocoDirs = 'reports'
    ext.jacocoInfoFile = jacocoDirs+'/jacocoInfo.txt'
    repositories {
        mavenLocal()
        google()
        mavenCentral()
    }
    dependencies {
        classpath "io.github.ckenergy:jacocox-report:$JacocoX_version"
    }
}
dependencies {
    implementation "org.jacoco:org.jacoco.agent:$jacoco_version:runtime"
    implementation "org.jacoco:org.jacoco.agent:$jacoco_version"
    implementation "org.jacoco:org.jacoco.ant:$jacoco_version"
    implementation "io.github.ckenergy:jacocox-generate:$JacocoX_version"
}
apply plugin: 'JacocoX'


def coverageSourceDirs = []

//class文件路径，如果你只有app一个module，那么就写一个就可以
def coverageClassDirs = []

def coverageFile = 'outputs/code-coverage/coverage'
def mergeName = 'coverage.ec'
def reportFile = "$jacocoDirs/jacoco/jacocoTestReport/html"

//Jacoco 版本，建议用这个版本兼容性比较好
jacoco{
    toolVersion = jacoco_version
}

import com.ckenergy.jacocox.report.JacocoInfo
import com.ckenergy.jacocox.report.JacocoXReport
import com.google.gson.Gson
import kotlin.Pair

afterEvaluate {
    // 1. 找到需要依赖自己 Task的构建流程的Task
    def assembleTask = tasks.findAll { task->
        return task.name.contains("assemble")
    }
    println "assemble=$assembleTask"
    // 2. 通过dependsOn 方法，插入到指定Task之前
    assembleTask.forEach{
        it.dependsOn(clearReport)
    }
}

task clearReport() {
    // 动态指定依赖
    group = "JacocoXReport"
    doLast {
        println("task clearReport")
        def repFile = file("$buildDir/$reportFile")
        if(repFile.exists()) {
            println("repFile:"+repFile.deleteDir())
        }
        def covFile = file("$buildDir/$coverageFile")
        if(covFile.exists()) {
            println("covFile:"+covFile.deleteDir())
        }

    }
}

//生成报告task
task jacocoTestMerge(type: JacocoMerge) {
    group = "JacocoXReport"
    description = "Generate Jacoco merge reports after running tests."

    executionData = fileTree(dir: "$buildDir/$coverageFile/")
    println("jacocox merge ${executionData.files}")
    destinationFile = file("$buildDir/$coverageFile/$mergeName")

    doFirst {
        File file = new File("$buildDir/$coverageFile/$mergeName")
        if (!file.exists()) {
            file.delete()
        }
    }
}

//生成报告task
task jacocoTestReport(type: JacocoXReport) {
    group = "JacocoXReport"
    description = "Generate Jacoco coverage reports after running tests."
    reports {
        xml.enabled = false
        html.enabled = true
        html.outputLocation = file("$buildDir/$reportFile")
    }

    def subProjectSet = this.rootProject.subprojects
    def dirs = getClassAndSource(subProjectSet, projectDir.absolutePath, "$buildDir/$jacocoInfoFile")

    if (dirs != null) {
        dirs.first.forEach {
            coverageClassDirs.add(it)
        }
        dirs.second.forEach {
            coverageSourceDirs.add(it)
        }
    }

    classDirectories.from = files(files(coverageClassDirs).files.collect {
        fileTree(dir: it,
                // 过滤不需要统计的class文件
                excludes: [
                           '**/*$InjectAdapter.class',
                           '**/*$ModuleAdapter.class',
                           // data binding
                           'android/databinding/**/*.class',
                           '**/android/databinding/*Binding.class',
                           '**/android/databinding/*',
                           '**/androidx/databinding/*',
                           '**/BR.*',
                           // android
                           '**/R.class',
                           '**/R$*.class',
                           '**/BuildConfig.*',
                           '**/Manifest*.*',
//                           '**/*Test*.*',
                           'android/**/*.*',
                           // dagger
                           '**/*_MembersInjector.class',
                           '**/Dagger*Component.class',
                           '**/Dagger*Component$Builder.class',
                           '**/Dagger*Subcomponent*.class',
                           '**/*Subcomponent$Builder.class',
                           '**/*Module_*Factory.class',
//                           '**/di/module/*',
//                           '**/*_Factory*.*',
//                           '**/*Module*.*',
//                           '**/*Dagger*.*',
//                           '**/*Hilt*.*',
                           // kotlin
                           '**/*MapperImpl*.*',
                           '**/*$ViewInjector*.*',
                           '**/*$ViewBinder*.*',
                           '**/BuildConfig.*',
//                           '**/*Component*.*',
                           '**/Manifest*.*',
//                           '**/*$Lambda$*.*',
//                           '**/*Companion*.*',
                           '**/*MembersInjector*.*',
                           '**/*_MembersInjector.class',
                           '**/*_Provide*Factory*.*',
//                           '**/*Extensions*.*',
                           // sealed and data classes
//                           '**/*$Result.*',
//                           '**/*$Result$*.*',
                           // adapters generated by moshi
                           '**/*JsonAdapter.*',
                ])
    })
    println("===SourceDirs" + coverageSourceDirs)
    println("===classDirs " + coverageClassDirs)

    sourceDirectories.from = files(coverageSourceDirs)
    executionData.from = files("$buildDir/$coverageFile/$mergeName")

    doFirst {
        coverageClassDirs.each { path ->
            new File(path).eachFileRecurse { file ->
                if (file.name.contains('$$')) {
                    file.renameTo(file.path.replace('$$', '$'))
                }
            }
        }
    }
}

//初始化Jacoco Task
task jacocoInit() {
    group = "JacocoXReport"
    doFirst {
        File file = new File("$buildDir/$coverageFile/")
        if (!file.exists()) {
            file.mkdirs()
        }
    }
}

def getClassAndSource(Set<Project> subProjectSet, String projectFile, String fileName) {
    //获取上一次构建的变体（buildType和flavor），注意同一个变体生成的ec报告必须
    def jacocoInfo = getJacocoInfo(fileName)
    if (jacocoInfo == null) return null

    def variant = jacocoInfo.variant

    //默认的路径
    def sourceDirs = []
    def classDirs = []
    subProjectSet.forEach{
        classDirs.add("${it.buildDir}/intermediates/javac/$variant/classes")
        classDirs.add("${it.buildDir}/tmp/kotlin-classes/$variant")
        if (!it.plugins.hasPlugin("com.android.application")) {
//        }else if (it.plugins.hasPlugin("com.android.library")) { 获取其他moudle的plugins为空，所以只能把可能得都添加一遍
            if (variant.toLowerCase().contains('debug')) {
                classDirs.add("${it.buildDir}/intermediates/javac/debug/classes")
                classDirs.add("${it.buildDir}/tmp/kotlin-classes/debug")
            }else {
                classDirs.add("${it.buildDir}/intermediates/javac/release/classes")
                classDirs.add("${it.buildDir}/tmp/kotlin-classes/release")
            }
//        }else {
            classDirs.add("${it.buildDir}/classes/kotlin/main")
            classDirs.add("${it.buildDir}/classes/java/main")
        }
        sourceDirs.add("../${it.name}/src/main/java")
        sourceDirs.add("../${it.name}/src/${jacocoInfo.buildType}/java")
        if (jacocoInfo.flavor != null) {
            jacocoInfo.flavor.forEach { fla ->
                sourceDirs.add("../${it.name}/src/$fla/java")
            }
        }
    }
    classDirs = classDirs.findAll {
        def testExecFile = file(it)
        return testExecFile.exists()
    }
    sourceDirs = sourceDirs.findAll {
        def testExecFile = file("$projectFile/"+it)
        return testExecFile.exists()
    }
    return new Pair<List<String>, List<String>>(classDirs, sourceDirs)
}

def getJacocoInfo(String fileName) {
    try {
        def infoFile = file(fileName)
        if (infoFile.canRead()) {
            return new Gson().fromJson(new String(infoFile.readBytes()), JacocoInfo.class)
        }
    }catch (Exception e) {
        e.printStackTrace()
    }
    return null
}